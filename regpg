#!/usr/bin/perl

use warnings;
use strict;

use File::Temp qw(tempfile);
use Getopt::Std;
use MIME::Base64;

sub usage {
	print STDERR <<EOF;
usage:	regpg help
	regpg find
	regpg addkey [options] <keyname>...
	regpg delkey [options] <keyname>...
	regpg lskeys [options]
	regpg genpwd [options] <cryptfile>
	regpg encrypt [options] [clearfile] <cryptfile>
	regpg decrypt [options] <cryptfile> [clearfile]
	regpg recrypt [options] <cryptfile>...
	regpg lscrypt [options] <cryptfile>
options:
	-k <pubring.gpg>	recipient keyring
	-n			no changes (implies -v)
	-r			recrypt all files after keyring changes
	-v			verbose mode
Either or both file arguments to `encrypt` and `decrypt`
can be '-' meaning stdin or stdout. Omitted clearfile
arguments are equivalent to '-'.
EOF
	exit 1;
}

sub help {
	exec "perldoc -F $0";
}

our %opt;
our @gpg;
our @gpg_de;
our @gpg_en;

sub getargs {
	my $argmin = shift;
	my $argmax = shift;
	usage unless getopts '-hk:nrv', \%opt;
	help if $opt{h};
	$opt{k} //= './pubring.gpg';
	$opt{v} = 1 if $opt{n};
	usage if @ARGV < $argmin;
	usage if defined $argmax and @ARGV > $argmax;
	@gpg = (qw(gpg --no-default-keyring --keyring),$opt{k});
	@gpg_de = qw(gpg --use-agent --batch --quiet --decrypt);
	@gpg_en = (@gpg, qw(--trust-model=always --armor --encrypt));
}

sub getout {
	return  $ARGV[0] eq '-' ? () : ('--output', $ARGV[0]);
}

sub getinout {
	my $in = shift @ARGV;
	return getout, $in eq '-' ? () : $in;
}

sub verbose {
	print STDERR "@_\n" if $opt{v};
}

sub vsystem {
	verbose "running @_";
	return if $opt{n};
	return if 0 == system @_;
	die "failed: @_\n";
}

sub vexec {
	vsystem @_;
	exit $?;
}

sub vsystem_warn {
	eval { vsystem @_ };
}

sub pipeslurp {
	verbose "pipe from @_";
	return if $opt{n};
	open my $pipe, '-|', @_
	    or die "open pipe from $_[0]: $!\n";
	my @out = <$pipe>;
	unless (close $pipe) {
		die "read pipe from $_[0]: $!\n" if $!;
		die "pipe from $_[0] failed\n";
	}
	return @out;
}

sub pipespew {
	my $data = shift;
	verbose "pipe to @_";
	return if $opt{n};
	open my $pipe, '|-', @_
	    or die "open pipe to $_[0]: $!\n";
	print $pipe $data;
	unless (close $pipe) {
		die "write pipe to $_[0]: $!\n" if $!;
		die "pipe to $_[0] failed\n";
	}
}

sub recipients {
	my $save = $opt{n}; undef $opt{n};
	my @keys = map m{^(?:[^:]*:){4}([^:]*):},
	    grep m{^pub:},
	    pipeslurp @gpg, qw(--list-keys --with-colons);
	$opt{n} = $save;
	return map { ('--recipient' => $_) } @keys;
}

sub find_all {
	my $save = $opt{n}; undef $opt{n};
	my @files = pipeslurp q(find . -type f |
		xargs grep -l '^-----BEGIN PGP MESSAGE-----$');
	$opt{n} = $save;
	return map m{^([^\n]+)\n*$}, @files;
}

# save stdout once
open my $stdout, '>&STDOUT' or die "dup: $!\n";

sub recrypt_one {
	my $fn = shift;
	my @recipients = @_;
	my $cleartext = join '', pipeslurp @gpg_de, $fn;
	if ($opt{n}) {
		verbose "pipe to", @gpg_en, @recipients,
		    '--output', $fn;
		return;
	}
	my ($th,$tn) = tempfile "$fn.XXXXXXXX";
	verbose "tempfile $tn";
	open STDOUT, '>&', $th or die "dup: $!\n";
	pipespew $cleartext, @gpg_en, @recipients;
	open STDOUT, '>&', $stdout or die "dup: $!\n";
	verbose "rename $tn => $fn";
	rename $tn => $fn
	    or die "rename $tn => $fn: $!\n";
}

sub recrypt_some {
	my @recipients = recipients;
	recrypt_one $_, @recipients for @_;
}

sub recrypt_all {
	recrypt_some find_all;
}

# subcommands

sub addkey {
	getargs 1;
	# Export from the user's normal gpg setup. export-minimal
	# removes extraneous signatures from the key, which avoids
	# complaints about unavailable public keys when it is imported
	my $keys = join '',
	    pipeslurp qw(gpg --export --armor
			 --export-options export-minimal),
			     @ARGV;
	# Import to this local keyring
	pipespew $keys, @gpg, '--import';
	recrypt_all if $opt{r};
	return 0;
}

sub delkey {
	getargs 1;
	# --expert persuades gpg to delete the key even if the secret
	# key is available, when deleting one of the user's own keys
	vsystem @gpg, '--expert', '--delete-key', @ARGV;
	recrypt_all if $opt{r};
	return 0;
}

sub lskeys {
	getargs 0, 0;
	vexec @gpg, '--fingerprint';
}

sub genpwd {
	getargs 1, 1;
	open my $fh, '<', '/dev/urandom'
	    or die "open /dev/urandom: $!\n";
	my $len = 15;
	$len == sysread $fh, my $bytes, $len
	    or die "read /dev/urandom: $!\n";
	my $chars = encode_base64 $bytes;
	pipespew $chars, @gpg_en, recipients, getout;
	return 0;
}

sub encrypt {
	getargs 1, 2;
	unshift @ARGV, '-' if @ARGV == 1;
	vexec @gpg_en, recipients, getinout;
}

sub decrypt {
	getargs 1, 2;
	push @ARGV, '-' if @ARGV == 1;
	vexec @gpg_de, getinout;
}

sub recrypt {
	getargs 0;
	if ($opt{r}) {
		usage unless @ARGV == 0;
		recrypt_all;
	} else {
		usage unless @ARGV > 0;
		recrypt_some @ARGV;
	}
	return 0;
}

sub lscrypt {
	getargs 1, 1;
	my @keys = grep s{^.*ENC_TO\s+(\S+)\s+.*\n}{$1},
	    pipeslurp @gpg, qw(--list-only --status-fd 1), @ARGV;
	vsystem_warn @gpg, '--fingerprint', $_ for @keys;
	return 0;
}

sub find {
	getargs 0;
	print "$_\n" for find_all;
	return 0;
}

usage unless @ARGV;
my $subcommand = shift;
if (grep $subcommand eq $_,
    qw(help find addkey delkey lskeys
       genpwd encrypt decrypt recrypt lscrypt)) {
	exit $::{$subcommand}();
} else {
	usage;
}

__END__

=head1 NAME

regpg - manage gpg-encrypted secrets

=head1 SYNOPSIS

B<regpg> B<help>

B<regpg> B<find>

B<regpg> B<addkey> [I<options>] <I<keyname>>...

B<regpg> B<delkey> [I<options>] <I<keyname>>...

B<regpg> B<lskeys> [I<options>]

B<regpg> B<genpwd> [I<options>] <I<cryptfile>>

B<regpg> B<encrypt> [I<options>] [I<clearfile>] <I<cryptfile>>

B<regpg> B<decrypt> [I<options>] <I<cryptfile>> [I<clearfile>]

B<regpg> B<recrypt> [I<options>] <I<cryptfile>>...

B<regpg> B<lscrypt> [I<options>] <I<cryptfile>>

=head1 DESCRIPTION

The B<regpg> program is a thin wrapper around gpg
to help with managing secrets that need to be stored encrypted
in revision control for a configuration management system.
These secrets need to be decrypted only in controlled circumstances.

You use the B<regpg> B<*keys> subcommands to maintain a GPG public key
ring file (by default F<./pubring.gpg>) which lists the set of people
who can decrypt the secrets.

You use the B<regpg> B<*crypt> subcommands to manage encrypted files.
The encryption recipients are all the keys in the pubic key ring.
Decryption is non-interactive, using B<gpg-agent>.

=head1 OPTIONS

The B<regpg> subcommands all take the same options.

=over

=item B<-k> I<pubring.gpg>

Specify the name of the public key ring file,
to override the default F<./pubring.gpg>.

=item B<-n>

Do nothing, but show what would have been done.

=item B<-r>

For the B<addkey>, B<delkey>, and B<recrypt> subcommands,
recrypt all files found by the B<find> subcommand.

=item B<-v>

Verbose mode. This mainly prints the GPG commands.

=back

=head1 SUBCOMMANDS

=over

=item B<regpg> B<help>

Display this documentation.

=item B<regpg> B<find>

Recursively find and list all encrypted files.
These are the files that are recryped by the B<-r> option.

=item B<regpg> B<addkey> <I<keyname>>...

Export keys from your default GPG public keyring,
and import them into the B<regpg> keyring.

A I<keyname> can be a key fingerprint or ID
or a person's email address.

If the B<-r> option is given,
all files are recrypted after the key is added.

=item B<regpg> B<delkey> <I<keyname>>...

Delete keys from the B<regpg> keyring.

A I<keyname> can be a key fingerprint or ID
or a person's email address.

If the B<-r> option is given,
all files are recrypted after the key is added.

=item B<regpg> B<lskeys>

List the keys in the B<regpg> keyring.

=item B<regpg> B<genpwd> <I<cryptfile>>

Generate a 20 character password, encrypt it, and store it in I<cryptfile>.

If I<cryptfile> is C<-> then it is written to stdout.

=item B<regpg> B<encrypt> [I<clearfile>] <I<cryptfile>>

Encrypt I<clearfile> to produce I<cryptfile>.
The encryption recipients are all the keys in the pubic key ring.

If I<clearfile> is C<-> or is omitted then it is read from stdin.

If I<cryptfile> is C<-> then it is written to stdout.

=item B<regpg> B<decrypt> <I<cryptfile>> [I<clearfile>]

Decrypt I<cryptfile> to produce I<clearfile>.
You must be running C<gpg-agent> which will be used
to gain access to your private key for decryption.

If I<cryptfile> is C<-> then it is read from stdin.

If I<clearfile> is C<-> or is omitted then it is written to stdout.

=item B<regpg> B<recrypt> <I<cryptfile>>...

Re-encrypt I<cryptfile>s.
If the B<-r> option is given,
all files are re-encrypted.

You should use this after using B<addkey> or B<delkey>,
if you did not pass the B<-r> option.

=item B<regpg> B<lscrypt> <I<cryptfile>>

List the keys which are able to decrypt I<cryptfile>.

=back

=head1 ANSIBLE VAULT

You can use B<regpg> to manage your B<ansible-vault> password.

Create a vault password:

	$ regpg genpwd vault.pwd

Create a decryption script:

	$ cat >vault.open
	#!/bin/sh
	regpg decrypt vault.pwd
	^D
	$ chmod +x vault.open

To set up automatic decryption, edit F<ansible.cfg> to add

	[default]
	vault_password_file = ./vault.open

=head1 ANSIBLE WITHOUT VAULT

Accompanying B<regpg> is an Ansible Jinja2 filter plugin called
B<gpg_d> that decrypts secrets for deployment on servers.

To set up the B<gpg_d> filter plugin, copy it into a F<plugins/filter>
subdirectory, next to your B<roles> subdirectory.
Edit F<ansible.cfg> to add

	[default]
	filter_plugins = plugins/filter

Ansible filter plugins work in Jinja2 templates. For example,

	- name: install ssh host keys
	  copy:
	    dest: /etc/ssh/{{ item | replace(".asc","") }}
	    content: "{{ item | gpg_d }}"
	  with_items
	    - ssh_host_dsa_key.asc
	    - ssh_host_ecdsa_key.asc
	    - ssh_host_ed25519_key.asc
	    - ssh_host_rsa_key.asc

=head1 SEE ALSO

gpg(1), gpg-agent(1)

=cut
