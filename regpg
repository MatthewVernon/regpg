#!/usr/bin/perl

use warnings;
use strict;

use File::Temp qw(tempfile);
use Getopt::Std;
use MIME::Base64;
use POSIX;
use Term::ANSIColor;

sub usage {
	print STDERR <<EOF;
usage:	regpg help
	regpg addkey [options] <keyname>...
	regpg delkey [options] <keyname>...
	regpg lskeys [options]
	regpg genpwd [options] <cryptfile>
	regpg encrypt [options] [clearfile] <cryptfile>
	regpg decrypt [options] <cryptfile> [clearfile]
	regpg recrypt [options] <cryptfile>...
	regpg check [options] <cryptfile>...
options:
	-k <pubring.gpg>	recipient keyring
	-n			no changes (implies -v)
	-r			recrypt all files after keyring changes
	-v			verbose mode
Either or both file arguments to `encrypt` and `decrypt`
can be '-' meaning stdin or stdout. Omitted clearfile
arguments are equivalent to '-'.
EOF
	exit 1;
}

sub help {
	exec "perldoc -F $0";
}

our %opt;
our @gpg;
our @gpg_de;
our @gpg_en;

sub getargs {
	my %arg = @_;
	usage unless getopts '-hk:nrv', \%opt;
	help if $opt{h};
	$opt{k} //= './pubring.gpg';
	$opt{v} = 1 if $opt{n};
	usage if @ARGV < $arg{min};
	usage if defined $arg{max} and @ARGV > $arg{max};
	die "regpg: $opt{k} not found\n"
	    unless -f $opt{k} or $arg{keymaker};
	$opt{k} = "./$opt{k}" unless $opt{k} =~ m{/};
	@gpg = (qw(gpg --no-default-keyring --keyring),$opt{k});
	@gpg_de = qw(gpg --use-agent --batch --quiet --decrypt);
	@gpg_en = (@gpg, qw(--trust-model=always --armor --encrypt));
}

sub getout {
	return  $ARGV[0] eq '-' ? () : ('--output', $ARGV[0]);
}

sub getinout {
	my $in = shift @ARGV;
	return getout, $in eq '-' ? () : $in;
}

sub verbose {
	print STDERR "@_\n" if $opt{v};
}

sub vsystem {
	verbose "running @_";
	return if $opt{n};
	return if 0 == system @_;
	die "failed: @_\n";
}

sub vexec {
	vsystem @_;
	exit $?;
}

sub vsystem_warn {
	eval { vsystem @_ };
}

sub pipeslurp {
	verbose "pipe from @_";
	return if $opt{n};
	open my $pipe, '-|', @_
	    or die "open pipe from $_[0]: $!\n";
	my @out = <$pipe>;
	unless (close $pipe) {
		die "read pipe from $_[0]: $!\n" if $!;
		die "pipe from $_[0] failed\n";
	}
	return @out;
}

sub pipespew {
	my $data = shift;
	verbose "pipe to @_";
	return if $opt{n};
	open my $pipe, '|-', @_
	    or die "open pipe to $_[0]: $!\n";
	print $pipe $data;
	unless (close $pipe) {
		die "write pipe to $_[0]: $!\n" if $!;
		die "pipe to $_[0] failed\n";
	}
}

sub ring_keys {
	my $save = $opt{n}; undef $opt{n};
	# get the key ID of each encryption-capable public key or subkey
	my @keys = map m{^(?:[^:]*:){4}([^:]*):},
	    grep m{^[ps]ub:.*:\w*e\w*:$},
	    pipeslurp @gpg, qw(--list-keys --with-colons);
	$opt{n} = $save;
	return @keys;
}

sub recipients {
	return map { ('--recipient' => $_) } ring_keys;
}

sub find_all {
	my $save = $opt{n}; undef $opt{n};
	my @files = pipeslurp q(find . -type f |
		xargs grep -l '^-----BEGIN PGP MESSAGE-----$');
	$opt{n} = $save;
	return map m{^([^\n]+)\n*$}, @files;
}

# save stdout once
open my $stdout, '>&STDOUT' or die "dup: $!\n";

sub recrypt_one {
	my $fn = shift;
	my @recipients = @_;
	my $cleartext = join '', pipeslurp @gpg_de, $fn;
	if ($opt{n}) {
		verbose "pipe to", @gpg_en, @recipients,
		    '--output', $fn;
		return;
	}
	my ($th,$tn) = tempfile "$fn.XXXXXXXX";
	verbose "tempfile $tn";
	open STDOUT, '>&', $th or die "dup: $!\n";
	pipespew $cleartext, @gpg_en, @recipients;
	open STDOUT, '>&', $stdout or die "dup: $!\n";
	verbose "rename $tn => $fn";
	rename $tn => $fn
	    or die "rename $tn => $fn: $!\n";
}

sub recrypt_some {
	my @recipients = recipients;
	recrypt_one $_, @recipients for @_;
	return 0;
}

sub maybe_recrypt_all {
	recrypt_some find_all if $opt{r};
}

sub check_quiet {
	my $fn = shift;
	my @ring = @_;
	my @file = grep s{^.*ENC_TO\s+(\S+)\s+.*\n}{$1},
	    pipeslurp @gpg, qw(--list-only --status-fd 1), $fn;
	# diff key lists
	my %ring; @ring{@ring} = (); delete @ring{@file};
	my %file; @file{@file} = (); delete @file{@ring};
	@ring = keys %ring;
	@file = keys %file;
	my $clear = ($fn =~ m{^(.*)[.](asc|gpg)$} && -f $1)
	    ? $1 : undef;
	return ( ring => [ @ring ],
		 file => [ @file ],
		 diff => (!!@ring || !!@file),
		 clear => $clear );
}

sub diff_del {
	return map colored("-$_", "red"), @_;
}
sub diff_add {
	return map colored("+$_", "green"), @_;
}
sub holy_crap {
	return colored " CLEARTEXT @_", "bright_white on_bright_red";
}

sub check_one {
	my $fn = shift;
	my %ck = check_quiet $fn, @_;
	return 0 if $opt{n};
	print $fn,
	    $ck{clear} ? "\t" . holy_crap : "",
	    $ck{diff} ? "\t" : "",
	    diff_del(@{ $ck{file} }),
	    diff_add(@{ $ck{ring} }),
	    "\n";
	return !!$ck{clear} || $ck{diff};
}

sub fingerprint {
	my @r;
	eval { @r = pipeslurp @gpg, '--fingerprint', @_; };
	return @r if @r;
	eval { @r = pipeslurp 'gpg', '--fingerprint', @_; };
	return @r if @r;
	return "no fingerprint for @_\n", "\n";
}

sub check_long {
	my $fn = shift;
	my %ck = check_quiet $fn, @_;
	return 0 if $opt{n};
	print " checking: $fn\n";
	printf "%s\n", holy_crap $ck{clear}
	    if $ck{clear};
	print diff_del fingerprint $_ for @{ $ck{file} };
	print diff_add fingerprint $_ for @{ $ck{ring} };
	return !!$ck{clear} || $ck{diff};
}

sub check_some {
	my @ring_keys = ring_keys;
	return check_long @_, @ring_keys if @_ == 1;
	my $r = 0;
	$r |= check_one $_, @ring_keys for @_;
	return $r;
}

sub for_files {
	my ($zap,$sub) = @_;
	getargs min => 0;
	if (@ARGV and $opt{r}) {
		die "regpg: either -r or arguments, not both\n";
	} elsif (@ARGV) {
		return &$sub(@ARGV);
	} elsif ($opt{r} or $zap eq 'zap') {
		return &$sub(find_all);
	} else {
		die "regpg: use -r to really $zap all files\n";
	}
}

# subcommands

sub addkey {
	getargs keymaker => 1, min => 1;
	# Export from the user's normal gpg setup. export-minimal
	# removes extraneous signatures from the key, which avoids
	# complaints about unavailable public keys when it is imported
	my $keys = join '',
	    pipeslurp qw(gpg --export --armor
			 --export-options export-minimal),
			     @ARGV;
	# Import to this local keyring
	pipespew $keys, @gpg, '--import';
	maybe_recrypt_all;
	return 0;
}

sub delkey {
	getargs keymaker => 1, min => 1;
	# --expert persuades gpg to delete the key even if the secret
	# key is available, when deleting one of the user's own keys
	vsystem @gpg, '--expert', '--delete-key', @ARGV;
	maybe_recrypt_all;
	return 0;
}

sub lskeys {
	getargs min => 0, max => 0;
	vexec @gpg, '--fingerprint';
}

sub genpwd {
	getargs min => 1, max => 1;
	open my $fh, '<', '/dev/urandom'
	    or die "open /dev/urandom: $!\n";
	my $len = 15;
	$len == sysread $fh, my $bytes, $len
	    or die "read /dev/urandom: $!\n";
	my $chars = encode_base64 $bytes;
	pipespew $chars, @gpg_en, recipients, getout;
	return 0;
}

sub encrypt {
	getargs min => 1, max => 2;
	unshift @ARGV, '-' if @ARGV == 1;
	vexec @gpg_en, recipients, getinout;
}

sub decrypt {
	getargs min => 1, max => 2;
	push @ARGV, '-' if @ARGV == 1;
	vexec @gpg_de, getinout;
}

sub recrypt {
	for_files recrypt => \&recrypt_some;
}

sub check {
	for_files zap => \&check_some;
}

my %longer = (
	'--help' => 'help',
	'add' => 'addkey',
	'del' => 'delkey',
	'ls' => 'lskeys',
	'pwd' => 'genpwd',
	'en' => 'encrypt',
	'decrypt' => 'decrypt',
	're' => 'recrypt',
	'ck' => 'check',
    );

usage unless @ARGV;
my $subcommand = shift;
$subcommand = $longer{$subcommand}
    if exists $longer{$subcommand};
if (grep $subcommand eq $_, values %longer) {
	exit $::{$subcommand}();
} else {
	usage;
}

__END__

=head1 NAME

regpg - manage gpg-encrypted secrets

=head1 SYNOPSIS

B<regpg> B<help>

B<regpg> B<addkey> [I<options>] <I<keyname>>...

B<regpg> B<delkey> [I<options>] <I<keyname>>...

B<regpg> B<lskeys> [I<options>]

B<regpg> B<genpwd> [I<options>] <I<cryptfile>>

B<regpg> B<encrypt> [I<options>] [I<clearfile>] <I<cryptfile>>

B<regpg> B<decrypt> [I<options>] <I<cryptfile>> [I<clearfile>]

B<regpg> B<recrypt> [I<options>] <I<cryptfile>>...

B<regpg> B<check> [I<options>] <I<cryptfile>>...

=head1 DESCRIPTION

The B<regpg> program is a thin wrapper around gpg
to help with managing secrets that need to be stored encrypted
in revision control for a configuration management system.
These secrets need to be decrypted only in controlled circumstances.

You use the B<regpg> B<*keys> subcommands to maintain a GPG public key
ring file (by default F<./pubring.gpg>) which lists the set of people
who can decrypt the secrets.

You use the B<regpg> B<*crypt> subcommands to manage encrypted files.
The encryption recipients are all the keys in the pubic key ring.
Decryption is non-interactive, using B<gpg-agent>.

The B<regpg> B<check> subcommand verifies that the encrypted files and
public keyring are consistent with each other.

=head1 OPTIONS

The B<regpg> subcommands all take the same options.

=over

=item B<-k> I<pubring.gpg>

Specify the name of the public key ring file,
to override the default F<./pubring.gpg>.

=item B<-n>

Do nothing, but show what would have been done.

=item B<-r>

For the B<addkey>, B<delkey>, and B<recrypt> subcommands,
recrypt all files found by the B<check> subcommand.

=item B<-v>

Verbose mode. This mainly prints the GPG commands.

=back

=head1 SUBCOMMANDS

Most subcommands have abbreviated synonyms.

=over

=item B<regpg> B<help>

Display this documentation.

=item B<regpg> B<addkey> <I<keyname>>...

=item B<regpg> B<add> <I<keyname>>...


Export keys from your default GPG public keyring,
and import them into the B<regpg> keyring.

A I<keyname> can be a key fingerprint or ID
or a person's email address.

If the B<-r> option is given,
all files are recrypted after the key is added.

=item B<regpg> B<delkey> <I<keyname>>...

=item B<regpg> B<del> <I<keyname>>...

Delete keys from the B<regpg> keyring.

A I<keyname> can be a key fingerprint or ID
or a person's email address.

If the B<-r> option is given,
all files are recrypted after the key is added.

=item B<regpg> B<lskeys>

=item B<regpg> B<ls>

List the keys in the B<regpg> keyring.

=item B<regpg> B<genpwd> <I<cryptfile>>

=item B<regpg> B<pwd> <I<cryptfile>>

Generate a 20 character password, encrypt it, and store it in I<cryptfile>.

If I<cryptfile> is C<-> then it is written to stdout.

=item B<regpg> B<encrypt> [I<clearfile>] <I<cryptfile>>

=item B<regpg> B<en> [I<clearfile>] <I<cryptfile>>

Encrypt I<clearfile> to produce I<cryptfile>.
The encryption recipients are all the keys in the pubic key ring.

If I<clearfile> is C<-> or is omitted then it is read from stdin.

If I<cryptfile> is C<-> then it is written to stdout.

=item B<regpg> B<decrypt> <I<cryptfile>> [I<clearfile>]

Decrypt I<cryptfile> to produce I<clearfile>.
You must be running C<gpg-agent> which will be used
to gain access to your private key for decryption.

If I<cryptfile> is C<-> then it is read from stdin.

If I<clearfile> is C<-> or is omitted then it is written to stdout.

=item B<regpg> B<recrypt> <I<cryptfile>>...

=item B<regpg> B<re> <I<cryptfile>>...

Decrypt and re-encrypt I<cryptfile>s.
If the B<-r> option is given,
all files are re-encrypted.

You should use this after using B<addkey> or B<delkey>,
if you did not pass the B<-r> option.

=item B<regpg> B<check> <I<cryptfile>>...

=item B<regpg> B<ck> <I<cryptfile>>...

Check I<cryptfile>s for consistency.

If no arguments are given, B<check>
recursively finds and lists all encrypted files.
These are the files that are recryped by the B<-r> option.

If a I<cryptfile> has a C<.asc> or a C<.gpg> extension,
and an adjacent file exists without the extension,
it is called out as a potential cleartext file.

Keys that can decrypt a I<cryptfile>
but are not present in the B<-k> I<pubring.gpg>
are listed in red with C<-> markers.

Keys are present in the B<-k> I<pubring.gpg>
but cannot decrypt a I<cryptfile>
are listed in green with C<+> markers.

If one argument is given then key fingerprints are printed in full,
otherwise the diffs just list bare key IDs.

These differences can be resolved by the B<recrypt> subcommand.

=back

=head1 EXAMPLES

=head2 Ansible Vault

You can use B<regpg> to manage your B<ansible-vault> password.

Create a vault password:

	$ regpg genpwd vault.pwd

Create a decryption script:

	$ cat >vault.open
	#!/bin/sh
	regpg decrypt vault.pwd
	^D
	$ chmod +x vault.open

To set up automatic decryption, edit F<ansible.cfg> to add

	[default]
	vault_password_file = ./vault.open

=head2 Ansible without Vault

Accompanying B<regpg> is an Ansible Jinja2 filter plugin called
B<gpg_d> that decrypts secrets for deployment on servers.

To set up the B<gpg_d> filter plugin, copy it into a F<plugins/filter>
subdirectory, next to your B<roles> subdirectory.
Edit F<ansible.cfg> to add

	[default]
	filter_plugins = plugins/filter

Ansible filter plugins work in Jinja2 templates. For example,

	- name: install ssh host keys
	  copy:
	    dest: /etc/ssh/{{ item | replace(".asc","") }}
	    content: "{{ item | gpg_d }}"
	  with_items
	    - ssh_host_dsa_key.asc
	    - ssh_host_ecdsa_key.asc
	    - ssh_host_ed25519_key.asc
	    - ssh_host_rsa_key.asc

=head1 SEE ALSO

gpg(1), gpg-agent(1)

=cut
